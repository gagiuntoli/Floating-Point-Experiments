# Loop-1

This example initializes a simple precision floating point variable:

    x = 1 = 2^0

and divides it successively until reaching `2^-126`.

    2^(-001) = 5.000000e-01 = 0 01111110 00000000000000000000000
    2^(-002) = 2.500000e-01 = 0 01111101 00000000000000000000000
    2^(-003) = 1.250000e-01 = 0 01111100 00000000000000000000000
    2^(-004) = 6.250000e-02 = 0 01111011 00000000000000000000000
    2^(-005) = 3.125000e-02 = 0 01111010 00000000000000000000000
    2^(-006) = 1.562500e-02 = 0 01111001 00000000000000000000000
    2^(-007) = 7.812500e-03 = 0 01111000 00000000000000000000000
    2^(-008) = 3.906250e-03 = 0 01110111 00000000000000000000000
    2^(-009) = 1.953125e-03 = 0 01110110 00000000000000000000000
    2^(-010) = 9.765625e-04 = 0 01110101 00000000000000000000000
    ...
    2^(-124) = 4.701977e-38 = 0 00000011 00000000000000000000000
    2^(-125) = 2.350989e-38 = 0 00000010 00000000000000000000000
    2^(-126) = 1.175494e-38 = 0 00000001 00000000000000000000000

If the compiler does not support gradual underflow then the
next result would be `0`, if not, it will print:

    2^(-127) = 5.877472e-39 = 0 00000000 10000000000000000000000
    2^(-128) = 2.938736e-39 = 0 00000000 01000000000000000000000
    2^(-129) = 1.469368e-39 = 0 00000000 00100000000000000000000
    ...
    2^(-148) = 2.802597e-45 = 0 00000000 00000000000000000000010
    2^(-149) = 1.401298e-45 = 0 00000000 00000000000000000000001
    0                       = 0 00000000 00000000000000000000000
